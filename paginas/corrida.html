<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Simulação de Corrida</title>
  <link rel="stylesheet" href="../style.css">
  <script defer src="../saveManager.js"></script>
  <!--
    Os arquivos de dados agora são carregados via fetch diretamente do
    diretório data/. As importações anteriores de ../dados/patrocinadores.js e
    ../dados/pilotos.js foram removidas, pois esses arquivos não existem
    mais no projeto.
  -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: 'Press Start 2P', monospace;
      padding: 20px;
      text-align: center;
    }

    h1, h2 {
      color: red;
      font-size: 14px;
    }

    p {
      font-size: 10px;
    }

    button {
      background-color: black;
      color: white;
      border: 2px solid red;
      padding: 8px 12px;
      margin-top: 20px;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      cursor: pointer;
    }

    button:hover {
      background-color: red;
      color: black;
    }

    canvas {
      margin-top: 30px;
      background-color: white;
    }
  </style>
  <script defer>
    // Variáveis globais de dados
    let jogo = {};
    let patrocinadores = [];
    let pilotos = [];

    /**
     * Carrega dados de patrocinadores e pilotos do diretório data via fetch.
     * Em seguida, simula a corrida e atualiza as finanças da equipe.  Toda a
     * lógica da corrida permanece idêntica à versão anterior, porém agora
     * depende de carregamento assíncrono.  Caso não seja possível carregar
     * os dados (por exemplo, se a página estiver sendo servida via file://
     * sem um servidor web), será exibida uma mensagem de erro.
     */
    window.onload = async () => {
      jogo = loadGameData();
      if (!jogo || !jogo.fabrica) {
        alert("Jogo não carregado.");
        location.href = "../index.html";
        return;
      }

      try {
        // Carrega dados de patrocinadores e pilotos
        const respPat = await fetch("../data/patrocinadores.json");
        patrocinadores = await respPat.json();
        const respPil = await fetch("../data/pilotos.json");
        pilotos = await respPil.json();
      } catch (err) {
        console.error(err);
        alert("Erro ao carregar dados de corrida. Verifique se está rodando em um servidor web.");
        return;
      }

      const resultados = simularCorrida();
      const container = document.getElementById("resultado");
      container.innerHTML = "<h2>Resultado da Corrida</h2>";
      resultados.forEach((piloto, i) => {
        const p = document.createElement("p");
        p.textContent = `${i + 1}º - ${piloto}`;
        container.appendChild(p);
      });

      // Determina posição da equipe de forma aleatória (1 a 20)
      jogo.resultadoUltimaCorrida = Math.floor(Math.random() * 20) + 1;
      const equipe = jogo.equipe;
      let entradas = 0;
      let saidas = 0;
      let custoSalarios = 0;

      if (!jogo.contratosPatrocinadores) jogo.contratosPatrocinadores = {};
      if (!jogo.historicoFinanceiro) jogo.historicoFinanceiro = [];
      if (!jogo.patrocinadores) jogo.patrocinadores = { alto: [], medio: [], baixo: [] };

      const rompidos = [], renovados = [], expirados = [];

      Object.keys(jogo.contratosPatrocinadores).forEach(nome => {
        const contrato = jogo.contratosPatrocinadores[nome];
        const dados = patrocinadores.find(p => p.nome === nome);
        if (!dados) return;

        const valor = dados.valorPorCorrida || 0;
        entradas += valor;
        contrato.duracao = (contrato.duracao || 1) - 1;

        const ruim = jogo.resultadoUltimaCorrida > 8;
        contrato.performanceRuimSeguidas = contrato.performanceRuimSeguidas || 0;
        if (ruim) contrato.performanceRuimSeguidas++;
        else contrato.performanceRuimSeguidas = 0;

        if (
          contrato.performanceRuimSeguidas >= (dados.tolerancia || 2) &&
          Math.random() < ((dados.riscoRompimento || 10) / 100)
        ) {
          ["alto", "medio", "baixo"].forEach(nivel => {
            const i = jogo.patrocinadores[nivel].indexOf(nome);
            if (i !== -1) jogo.patrocinadores[nivel].splice(i, 1);
          });
          delete jogo.contratosPatrocinadores[nome];
          rompidos.push(nome);
        }

        const interesse = dados.interessePorEquipe?.[equipe] ?? dados.interesseBase ?? 50;
        if (contrato.duracao <= 0 && jogo.resultadoUltimaCorrida <= 4 && interesse >= 80) {
          contrato.duracao = 3;
          contrato.performanceRuimSeguidas = 0;
          renovados.push(nome);
        }

        if (contrato.duracao <= 0 && !renovados.includes(nome)) {
          ["alto", "medio", "baixo"].forEach(nivel => {
            const i = jogo.patrocinadores[nivel].indexOf(nome);
            if (i !== -1) jogo.patrocinadores[nivel].splice(i, 1);
          });
          delete jogo.contratosPatrocinadores[nome];
          expirados.push(nome);
        }
      });

      // Custo com salários dos pilotos contratados
      if (jogo.pilotos) {
        jogo.pilotos.forEach(nome => {
          const piloto = pilotos.find(p => p.nome === nome);
          if (piloto) {
            custoSalarios += piloto.salarioMinimo || 0;
          }
        });
      }

      // Custo de manutenção da fábrica (pior fábrica = mais caro)
      const custoManutencao = Math.round((1 - (jogo.fabrica.nivel || 0)) * 1000000);
      saidas = custoSalarios + custoManutencao;

      jogo.dinheiro += entradas - saidas;

      jogo.historicoFinanceiro.push({
        corrida: jogo.historicoFinanceiro.length + 1,
        entradas: entradas,
        saidas: saidas,
        saldo: entradas - saidas
      });

      saveGame(jogo);

      const avisos = [];
      if (rompidos.length) avisos.push("❌ Patrocinadores rompidos: " + rompidos.join(", "));
      if (expirados.length) avisos.push("⚠️ Contratos expirados: " + expirados.join(", "));
      if (renovados.length) avisos.push("✅ Patrocinadores renovados: " + renovados.join(", "));
      if (avisos.length > 0) alert(avisos.join("\n"));

      // Gráfico de evolução do caixa usando Chart.js
      const labels = jogo.historicoFinanceiro.map(f => `Corrida ${f.corrida}`);
      const saldos = jogo.historicoFinanceiro.map(f => f.saldo);
      new Chart(document.getElementById("graficoCaixa"), {
        type: "line",
        data: {
          labels: labels,
          datasets: [{
            label: "Evolução do Caixa ($)",
            data: saldos,
            borderColor: "red",
            backgroundColor: "rgba(255, 0, 0, 0.2)",
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { labels: { color: "white", font: { size: 10 } } }
          },
          scales: {
            x: { ticks: { color: "white", font: { size: 8 } } },
            y: { ticks: { color: "white", font: { size: 8 } } }
          }
        }
      });
    };

    // Função simples de simulação de corrida.  Neste protótipo, a função
    // retorna apenas nomes fictícios.  Quando houver uma lógica mais
    // elaborada, substitua por um algoritmo de simulação realista.
    function simularCorrida() {
      return ["Piloto 1", "Piloto 2", "Piloto 3", "Piloto 4", "Piloto 5"];
    }
  </script>
</head>
<body>
  <h1>Corrida</h1>
  <div id="resultado"></div>
  <canvas id="graficoCaixa" width="600" height="300"></canvas>
  <br>
  <button onclick="window.location.href='../menu-principal.html'">Voltar</button>
</body>
</html>
